<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Getting Started | DotnetPrompt </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Getting Started | DotnetPrompt ">
    <meta name="generator" content="docfx ">
  
    <link rel="shortcut icon" href="../.././images/logo.svg">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
  
  <meta property="docfx:rel" content="../../">
  
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../.././images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">

        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="getting-started">Getting Started</h1>

<p>Using an LLM in isolation is fine for some simple applications, but many more complex ones require chaining LLMs -
either with each other or with other components.
DotnetPrompt provides a standard interface <code>IChains</code>, as well as some common implementations of chains for ease of use.</p>
<h2 id="why-do-we-need-chains">Why do we need chains?</h2>
<p>Chaining multiple LLM runs together (with the output of one step being the input to the next) can help users accomplish more complex tasks,
and in a way that is perceived to be more transparent and controllable.</p>
<h2 id="query-an-llm-with-the-modelchain">Query an LLM with the ModelChain</h2>
<p>The <code>ModelChain</code> is a simple chain that takes in a prompt template, formats it with the user input and returns the response from an LLM.</p>
<p>To use the <code>ModelChain</code>, first create a prompt template.</p>
<pre><code class="lang-csharp">var llm = new OpenAIModel(Constants.OpenAIKey, OpenAIModelConfiguration.Default with { Temperature = 0.9f });
var prompt = new PromptTemplate(&quot;What is a good name for a company that makes {product}?&quot;);
</code></pre>
<p>We can now create a very simple chain. To run the chain and get a result back we could use extension method <code>PromptAsync</code>.</p>
<pre><code class="lang-csharp">var chain = new ModelChain(prompt, llm);
var executor = chain.GetExecutor();

// Run the chain only specifying the input variable.
var result = await executor.PromptAsync(&quot;colorful socks&quot;);
Console.WriteLine(result);
</code></pre>
<pre><code class="lang-text">&gt; CheeryToes Sockery.
</code></pre>
<p>This is one of the simpler types of chains, but understanding how it works will set you up well for working with more complex chains.
More example how to use <code>ModelChain</code> could be found <a href="howto/model_chain.html">here</a>.</p>
<h2 id="creating-sequential-chains">Creating sequential chains</h2>
<p>The next step after calling a language model is make a series of calls to a language model. We can do this using sequential chains,
which are chains that execute their links in a predefined order. Specifically, we will use the <code>SequentialChain</code>.
This is the simplest form of sequential chains, where each step has a singular input/output, and the output of one step is the input to the next.</p>
<pre><code class="lang-csharp">var llm = new OpenAIModel(Constants.OpenAIKey, OpenAIModelConfiguration.Default with { Temperature = 0.9f });

// Setup model to create a company name for a product
var prompt = new PromptTemplate(&quot;What is a good name for a company that makes {product}?&quot;, new[] { &quot;product&quot; });
var chain = new ModelChain(prompt, llm)
{
    DefaultOutputKey = &quot;company_name&quot;
};

// Setup model to create a catchphrase for the product
var secondPrompt = new PromptTemplate(&quot;Write a catchphrase for the following company: {company_name}&quot;, new[] { &quot;company_name&quot; });
var chainTwo = new ModelChain(secondPrompt, llm);

// Combine the two chains, so that we can create a company name and a catchphrase in a single step.
var overallChain = new SequentialChain(new[] { chain, chainTwo });

// Run the chain specifying only the input variable for the first chain.
var executor = overallChain.GetExecutor();
var catchphrase = await executor.PromptAsync(&quot;colorful socks&quot;);

Console.WriteLine(catchphrase);
</code></pre>
<p>The result could look like this</p>
<pre><code class="lang-text">&gt; Bring out your true colors with Soxicolor!
</code></pre>
<h2 id="create-a-one-step-custom-chain-with-the-modelchain-class">Create a one-step custom chain with the <code>ModelChain</code> class</h2>
<p>DotnetPrompt provides set of specialized chains out of the box,
but sometimes you may want to create a custom chains for your specific use case.</p>
<p>The simplest way to create your own chain is to inherit <code>ModelChain</code> and provide custom prompt template.
This is useful to do when you need a chain which is a part of other, larger chains.</p>
<pre><code class="lang-charp">public class SummarizeChain : ModelChain
{
    private const string template = &quot;Summarize the following text.\r\n\r\n&quot; +
                                    &quot;Text:\r\n&quot; +
                                    &quot;{text}\r\n&quot; +
                                    &quot;---\r\n\r\n&quot; +
                                    &quot;Summary:&quot;;

    public override string DefaultOutputKey =&gt; &quot;summary&quot;;

    public SummarizeChain(ILargeLanguageModel llm, ILogger&lt;ModelChain&gt;? logger = null) : base(new PromptTemplate(template), llm, logger)
    {

    }
}
</code></pre>
<p>In example above <code>SummarizeChain</code> will have <em>input variables</em> same as created prompt and output variables equal to <code>DefaultOutputKey</code>.</p>
<h2 id="create-your-own-chain">Create your own chain</h2>
<div class="TIP">
<h5>Tip</h5>
<p>Chains designed as an extension of <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library">TPL.Dataflow</a> blocks.
If you want to master building your own chains it is recomended to make yourself familiar with it.</p>
</div>
<p>You could combine several chains together or link other Dataflow blocks to built a chain for your own purposes.</p>
<p>Imagine that you want to generate name and slogan for you company. For that task we could write a specialized chain that
take two other chains and broadcast a single input to both of them and combine result afterwards.</p>
<p>Our custom chain would implement <code>IChain</code> interface. In constructor of the chain we would get two chains and link them in a dataflow.</p>
<pre><code class="lang-csharp">    public ConcatenateChain(IChain one, IChain two)
    {
        InputVariables = one.InputVariables;

        _broadcast = new BroadcastBlock&lt;ChainMessage&gt;(e =&gt; e with {}); 
        var joinBlock = new JoinBlock&lt;ChainMessage, ChainMessage&gt;();

        _broadcast.LinkTo(one.InputBlock);
        _broadcast.LinkTo(two.InputBlock);

        // we PropagateCompletion so exceptions inside of the chain goes forward
        one.OutputBlock.LinkTo(joinBlock.Target1, new DataflowLinkOptions() { PropagateCompletion = true }); 
        two.OutputBlock.LinkTo(joinBlock.Target2, new DataflowLinkOptions() { PropagateCompletion = true }); 
</code></pre>
<p>Note that we link our chains' <code>InputBlock</code> to interanl <code>BroadcastBlock</code>. It will broadcast our propmt as <code>ChainMessage</code> to each chain.</p>
<p>We also create a <code>JoinBlock</code> to join results of our models.</p>
<p>The final step is to combine results in a single result string. The result would be provided through <code>OutputBlock</code> inside <code>ChainMessage.Values</code> with <code>DefaultOutputKey</code></p>
<pre><code class="lang-csharp">
        _finalTransformation =
            new TransformBlock&lt;Tuple&lt;ChainMessage, ChainMessage&gt;, ChainMessage&gt;(list =&gt;
            {
                var resultOne = list.Item1.Values[one.DefaultOutputKey];
                var resultTwo = list.Item2.Values[two.DefaultOutputKey];

                var resultDictionary = new Dictionary&lt;string, string&gt;
                {
                    { DefaultOutputKey, string.Concat(resultOne, &quot;\n&quot;, resultTwo) }
                };
                return new ChainMessage(resultDictionary)  { Id = list.Item1.Id };
            });

        joinBlock.LinkTo(_finalTransformation, new DataflowLinkOptions() { PropagateCompletion = true }); 
    }
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>It is crucial to set the <code>Id</code> of the final message to be the same as the <code>Id</code> of the input message: <code>return new ChainMessage(resultDictionary) { Id = list.Item1.Id };</code>
This is because the executor expects to receive a message with the same <code>Id</code>, and if it's missed, it will not be received.</p>
</div>
<p>The full class would look like this</p>
<pre><code class="lang-csharp">public class ConcatenateChain : IChain
{
    private readonly IChain _one;
    private readonly IChain _two;
    private readonly BroadcastBlock&lt;ChainMessage&gt; _broadcast;
    private readonly TransformBlock&lt;Tuple&lt;ChainMessage, ChainMessage&gt;, ChainMessage&gt; _finalTransformation;
    private CancellationTokenSource _cts = new(TimeSpan.FromMinutes(1));


    public ITargetBlock&lt;ChainMessage&gt; InputBlock =&gt; _broadcast;
    public ISourceBlock&lt;ChainMessage&gt; OutputBlock =&gt; _finalTransformation;
    
    
    public void Cancel()
    {
        _one.Cancel();
        _two.Cancel();
        _cts.Cancel();
    }

    public ConcatenateChain(IChain one, IChain two)
    {
        _one = one;
        _two = two;
        InputVariables = one.InputVariables;

        _broadcast = new BroadcastBlock&lt;ChainMessage&gt;(e =&gt; e with {}); // clone input record
        var joinBlock = new JoinBlock&lt;ChainMessage, ChainMessage&gt;();
        var options = new DataflowLinkOptions() { PropagateCompletion = true };

        _broadcast.LinkTo(one.InputBlock, options);
        _broadcast.LinkTo(two.InputBlock, options);

        one.OutputBlock.LinkTo(joinBlock.Target1, options); // we PropagateCompletion so exceptions inside of the chain goes forward
        two.OutputBlock.LinkTo(joinBlock.Target2, options); 

        _finalTransformation =
            new TransformBlock&lt;Tuple&lt;ChainMessage, ChainMessage&gt;, ChainMessage&gt;(list =&gt;
            {
                var resultOne = list.Item1.Values[one.DefaultOutputKey];
                var resultTwo = list.Item2.Values[two.DefaultOutputKey];

                var resultDictionary = new Dictionary&lt;string, string&gt;
                {
                    { DefaultOutputKey, string.Concat(resultOne, &quot;\n&quot;, resultTwo) }
                };
                return new ChainMessage(resultDictionary) { Id = list.Item1.Id };
            }, new ExecutionDataflowBlockOptions() { CancellationToken = _cts.Token });

        joinBlock.LinkTo(_finalTransformation, options); 
    }

    public IList&lt;string&gt; InputVariables { get; }
    public string DefaultOutputKey { get; set; } = &quot;text&quot;;
}
</code></pre>
<p>Then to use it we will create a couple <code>ModelChain</code> and provide them to constructor of <code>ConcatenateChain</code>.</p>
<pre><code class="lang-csharp">var llm = new OpenAIModel(Constants.OpenAIKey, OpenAIModelConfiguration.Default with { Temperature = 0.9f });

var prompt1 = new PromptTemplate(&quot;What is a good name for a company that makes {product}?&quot;, new[] {&quot;product&quot;});
var chain1 = new ModelChain(prompt1, llm, TestLogger.Create&lt;ModelChain&gt;())
{
    DefaultOutputKey = &quot;CompanyName&quot;
};

var prompt2 = new PromptTemplate(&quot;What is a good slogan for a company that makes {product}?&quot;, new[] {&quot;product&quot;});
var chain2 = new ModelChain(prompt2, llm, TestLogger.Create&lt;ModelChain&gt;())
{
    DefaultOutputKey = &quot;Slogan&quot;
};

var concatChain = new ConcatenateChain(chain1, chain2);

var executor = concatChain.GetExecutor();
var concatOutput = await executor.PromptAsync(&quot;colorful socks&quot;);
Console.WriteLine($&quot;Concatenated output:\n{concatOutput}&quot;);
</code></pre>
<p>When we execute this code, the result could look like this:</p>
<pre><code class="lang-text">&gt; Concatenated output:

Rainbow Steps Socks

&quot;Step Into Color with Our Socks!&quot;
</code></pre>
<p>One top of this both calls to LLM was done in parallel, which is one of the benefits of using Dataflow.</p>
</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/xakpc/DotnetPrompt/blob/main/docs/articles/chains/getting_started.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      <span>Copyright 2023 © Pavel <i>«xakpc»</i> Osadchuk for <strong>DotnetPrompt</strong></span>
      
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
